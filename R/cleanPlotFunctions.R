#' Cleans the ggplot object generated by \code{plotMarkerDistribution} for presentation.
#'
#' If each cell were made up purely of background reads, the expression fraction would equal that of the soup.  This plot compares this expectation of pure background to the observed expression fraction in each cell, for each of the groups of genes in \code{nonExpressedGeneList}.  For each group of genes, the distribution of this ratio is plotted across all cells.  A value significantly greater than 1 (0 on log scale) can only be obtained if some of the genes in each group are genuinely expressed by the cell.  That is, the assumption that the cell is pure background does not hold for that gene. This instance adds a \code{verboseContamination} parameter to pass to \code{\link{calculateContaminationFraction}} to tell it whether to print the estimated global contamination for each gene.
#'
#' This plot is a useful diagnostic for the assumption that a list of genes is non-expressed in most cell types.  For non-expressed cells, the ratio should cluster around the contamination fraction, while for expressed cells it should be elevated.  The most useful non-expressed gene sets are those for which the genes are either strongly expressed, or not expressed at all.  Such groups of genes will show up in this plot as a bimodal distribution, with one mode containing the cells that do not express these genes around the contamination fraction for this channel and another around a value at some value equal to or greater than 0 (1 on non-log scale) for the expressed cells.
#'
#' The red line shows the global estimate of the contamination for each group of markers.  This is usually lower than the low mode of the distribution as there will typically be a non-negligible number of cells with 0 observed counts (and hence -infinity log ratio).
#'
#' If nonExpressedGeneList is missing, this function will plot the distribution for the most highly expressed genes in the soup, excluding those whose distribution makes them unlikely to be useful. This is meant only as a heuristic, which can hopefully provide some inspiration as to a class of genes to use to estimation the contamination for your experiment.  It is **NOT** meant to be used blindly or algorithmically.  That is, do not feed this list of genes into \code{\link{calculateContaminationFraction}} without any manual consideration or filtering as this *will over-estimate your contamination* (sometime by a large amount).  For this reason, these gene names are not returned by the function. 
#'
#' @export
#' @param gg_plot A ggplot2 object passed from \code{plotMarkerDistribution}.
#' @param highlightGenes A vector of genes to highlight in the plot (note: undo any list formating with \code{unlist})
#' @param highlightColor A color to highlight selected genes
#' @param prefixDrop A string, such as a prefix, to remove from the gene names being plotted
#' @importFrom plyr empty
#' @importFrom stats setNames
#' @importFrom stringr str_remove
#' @return A ggplot2 object containing the plot.
cleanMarkerDistribution = function(gg_plot, highlightGenes=NULL, highlightColor="red", prefixDrop) {
  # Get the necessary raw data from the plot_env of the original ggplot object
  df = mget("df", gg_plot$plot_env)$df
  globalRhos = mget("globalRhos", gg_plot$plot_env)$globalRhos
  keep = mget("keep", gg_plot$plot_env)$keep
  # Get rid of the prefix tag at the beginning of every gene name
  df$MarkerGroup = str_remove(df$MarkerGroup, prefixDrop)
  globalRhos$MarkerGroup = str_remove(globalRhos$MarkerGroup, prefixDrop)
  # Get rid of the cells outside the keep vector (prevents warnings from being printed)
  df = df[df$Barcode %in% keep,]
  globalRhos = globalRhos[!is.na(globalRhos$rho), ]
  # Remake the gg object
  if (plyr::empty(globalRhos)) {
    gg = ggplot(df,aes(MarkerGroup,log10(Values))) +
      geom_violin() +
      geom_jitter(data=df,aes(size=log10(expCnts)),height=0,width=0.3,alpha=1/2) +
      # This is sort-of deprecated now that the qvals aren't calculated
      scale_colour_manual(values=c('TRUE'='red','FALSE'='black')) +
      # Highlight genes of interest
      theme(axis.text.x = element_text(angle = 90, hjust = 1, colour = ifelse(levels(factor(df$MarkerGroup)) %in% str_remove(highlightGenes, prefixDrop),
                                                                              highlightColor,
                                                                              "black"
      )
      )
      ) +
      labs(colour='expressed\nby cell')+
      ylab('log10(obs/exp)') +
      xlab('Marker Gene')
  }else{
    gg = ggplot(df,aes(MarkerGroup,log10(Values))) +
      geom_violin() +
      geom_jitter(data=df,aes(size=log10(expCnts)),height=0,width=0.3,alpha=1/2) +
      geom_line(data=globalRhos,aes(MarkerGroup,rho,group=1),colour='red') +
      geom_point(data=globalRhos,aes(MarkerGroup,rho,group=1),colour='red',shape=2) +
      # This is sort-of deprecated now that the qvals aren't calculated
      scale_colour_manual(values=c('TRUE'='red','FALSE'='black')) +
      # Highlight genes of interest
      theme(axis.text.x = element_text(angle = 90, hjust = 1, colour = ifelse(levels(factor(df$MarkerGroup)) %in% str_remove(highlightGenes, prefixDrop),
                                                                              highlightColor,
                                                                              "black"
      )
      )
      ) +
      labs(colour='expressed\nby cell')+
      ylab('log10(obs/exp)') +
      xlab('Marker Gene')  
  }
  return(gg)
}

#' Cleans the ggplot object generated by \code{plotMarkerMap} for presentation.
#'
#' Given some reduced dimensional representation of the data (such as UMAP or tSNE) that has been calculated however you would like, this provides a way to visualise how likely a set of genes are to be soup derived on that map.  That is, given a set of genes, this function calculates how many counts would be expected if that droplet were nothing but soup and compares that to the observed count.  This is done via a log2 ratio of the two values.  A Poisson test is performed and points that have a statistically significant enrichment over the background (at 5% FDR) are marked.
#'
#' @export
#' @param gg_plot ggplot2 object passed from \code{plotMarkerDistribution}
#' @return A ggplot2 containing the plot.
cleanMarkerMap = function(gg_plot) {
  # Get the necessary raw data from the plot_env of the original ggplot object
  DR = gg_plot$data
  colVal = mget('colVal', gg_plot$plot_env)$colVal
  ratLims = mget('ratLims', gg_plot$plot_env)$ratLims
  rescaled = mget('rescaled', gg_plot$plot_env)$rescaled
  # Reduce the useToEst matrix if it contains multiple gene sets
  if (colVal == "useToEst") {
    DR$useToEst = reduce(split(DR$useToEst, rep(1:ncol(DR$useToEst))), `|`) %>%
      matrix(dimnames = list(rownames(DR$useToEst), "useToEst"))
  }
  
  #Create the plot
  gg = ggplot(DR,aes(RD1,RD2)) +
    #Stick NAs underneath
    geom_point(data=DR[is.na(DR$logRatio),],aes_string(colour=colVal),size=0.25) +
    geom_point(data=DR[!is.na(DR$logRatio),],aes_string(fill='logRatio',colour=colVal),size=2.0,shape=21,stroke=0.5) +
    scale_colour_manual(values=c(`FALSE`='black',`TRUE`='#009933'))+
    xlab('ReducedDim1') +
    ylab('ReducedDim2') +
    scale_fill_gradientn(colours = c('blue','white','red'),
                         values = rescaled,
                         guide='colorbar',
                         limits=ratLims
    )
  return(gg)
}